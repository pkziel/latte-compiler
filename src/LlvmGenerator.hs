module LlvmGenerator (
    generateFunctions
) where

import qualified Data.Map as M
import System.IO
import Control.Monad.State
import Control.Monad.Reader

import AbsLatte
import Utils

type VarEnv a = M.Map Ident ((Type a), String)
type VarStore a = [VarEnv a]
type CounterState = (Int, Int) -- counter for registers, string constants
type Code a b = ReaderT (FEnv b) (StateT (CounterState, (VarStore b)) IO) a

generateFunctions :: (FEnv Liner) -> String ->  (TopDef Liner) -> IO(String) 
generateFunctions fenv acc (FnDef _ t (Ident id) args block) = do
    (consts, body) <- evalStateT (runReaderT (generateFun args block) fenv) initialStore
    return $ consts ++ acc ++ "define " ++ (printType t) ++ " @" ++ id ++ "(" ++ 
        (printArgsInFun args) ++ "){\n" ++ body ++ "}\n"

initialStore = ((1,1), [M.empty])

generateFun :: [Arg Liner] -> (Block Liner) -> Code (String, String) Liner
generateFun args (Block _ stmts) = do
    s1 <- foldM generateArgAlloca "" args
    (consts, s2) <- foldM generateStmts ("","") stmts
    return (consts, s1 ++ s2)

generateArgAlloca :: String -> (Arg Liner) -> Code String Liner
generateArgAlloca acc (Arg _ t i@(Ident id)) = do
    reg1 <- takeNewRegister
    insertNewVariable i t reg1
    return $ acc ++ printAlloca reg1 t ++ printStore t ("%" ++ id) reg1

takeNewRegister :: Code Int Liner
takeNewRegister = do
    ((x,y), v) <- get
    put (((x+1), y), v) 
    return x

addNewString :: Code String Liner
addNewString = do
    ((x,y), v) <- get
    put ((x, (y+1)), v) 
    return $ "@.str" ++ show y 

insertNewVariable :: Ident -> (Type Liner) -> Int ->  Code () Liner
insertNewVariable id t nr = do
    (p, s) <- get
    put (p, (M.insert id (t, ("%" ++ show nr)) (head s):(tail s)))

generateStmts :: (String, String) -> (Stmt Liner)-> Code (String, String) Liner
generateStmts (c1, s1) x = do
    (c2, s2) <- generateStmt x
    return (c1++c2, s1++s2)

generateStmt :: (Stmt Liner) -> Code (String, String) Liner
generateStmt (Empty _) = return ("","")
generateStmt (BStmt _ (Block _ stmts)) = do
    (p, s) <- get
    put (p, M.empty:s)
    res <- foldM generateStmts ("","") stmts
    modify (\(shouldStay, _) -> (shouldStay, s))
    return res
generateStmt (Decl _ t items) = foldM (generateDeclVar t) ("","") items
generateStmt (Ass _ i@(Ident id) exp) = do
    (type_, register) <- findVar i
    return ("", "")
generateStmt (Incr _ i@(Ident id)) = do
    (type_, register) <- findVar i
    newRegister <- takeNewRegister 
    return ("", printLoad newRegister type_ register)
generateStmt (Decr _ i@(Ident id)) = do
    (type_, register) <- findVar i
    newRegister <- takeNewRegister 
    return ("", printLoad newRegister type_ register)
generateStmt (Ret _ exp) = do
    ((consts, code), type_, val) <- generateExpr exp "" ""
    return (consts, code ++ "\tret " ++ printType type_ ++ " " ++ val ++ "\n")    
generateStmt (VRet _) = return ("", "\tret void\n")
generateStmt (Cond _ exp stmt) = return ("", "")
generateStmt (CondElse _ exp1 stmt1 stmt2) = return ("", "")
generateStmt (While _ exp stmt) = return ("", "")
generateStmt (SExp _ exp) = do
    ((consts, code), type_, val) <- generateExpr exp "" ""
    return (consts, code)

generateDeclVar :: (Type Liner) -> (String, String) -> (Item Liner) -> Code (String, String) Liner
generateDeclVar t (l,r) (NoInit _ i@(Ident id)) = do
    reg1 <- takeNewRegister
    insertNewVariable i t reg1
    return (l,r ++ printAlloca reg1 t ++ printStore t (giveInitialValue t) reg1)
generateDeclVar t (l,r) (Init _ i@(Ident id) exp) = do
    reg1 <- takeNewRegister
    insertNewVariable i t reg1
    return (l,r ++ printAlloca reg1 t ++ printStore t (giveInitialValue t) reg1)

findVar :: Ident -> Code ((Type Liner), String) Liner
findVar i = do
    (p, s) <- get
    findRegInStack i s

findRegInStack :: Ident -> (VarStore Liner) -> Code ((Type Liner), String) Liner
findRegInStack id (h:t) = case M.lookup id h of
    Nothing -> findRegInStack id t
    Just sth -> return sth  

-- we take expr, label true, label left
-- we return code generated by expr, type of result and register/value
generateExpr :: (Expr Liner) -> String -> String -> 
    Code ((String, String), (Type Liner), String) Liner
generateExpr (EVar _ id) _ _  = do
    (type_, register) <- findVar id
    return (("",""), type_, register)
generateExpr (ELitInt _ num) _ _  = return (("",""), (Int Nothing), show num)
generateExpr (ELitTrue _) _ _  = return (("",""), (Bool Nothing), "true")
generateExpr (ELitFalse _) _ _  = return (("",""), (Bool Nothing), "false")
generateExpr (EApp _ ident@(Ident i) exprs) _ _ = do
    (res) <- asks (M.lookup ident)
    case res of 
        Just (types, ret_typ) -> do
            (consts, preCode, inCode) <- foldM generateCallArgs ("","", []) exprs
            newRegister <- takeNewRegister
            return ((consts, preCode ++ printCall ret_typ newRegister i inCode), 
                ret_typ, "%" ++ show newRegister)
generateExpr (EString _ str) _ _ = do
    newRegStr <- addNewString
    return ((printStringConst newRegStr str, ""), (Str Nothing), newRegStr)

generateCallArgs :: (String, String, [((Type Liner), String)]) -> (Expr Liner) -> 
    Code (String, String, [((Type Liner), String)]) Liner
generateCallArgs (acc1, acc2, acc3) exp = do
    ((consts, code), type_, res) <- generateExpr exp "" ""
    return (acc1 ++ consts, acc2 ++ code, acc3 ++ [(type_, res)] )